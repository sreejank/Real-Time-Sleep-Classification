{\rtf1\ansi\ansicpg1252\deff0\deflang1033\deflangfe1033{\fonttbl{\f0\froman\fprq2\fcharset0 Times New Roman;}{\f1\fmodern\fprq1\fcharset0 Courier New;}{\f2\fnil\fcharset2 Symbol;}}
{\colortbl ;\red0\green0\blue255;}
{\*\generator Msftedit 5.41.21.2510;}\viewkind4\uc1\pard\nowidctlpar\b\f0\fs28 Sample C Client Programs for OmniPlex and MAP Systems\b0\fs20\par
Version 2.3\par
4/23/2013\par
\par
\par
\b\fs24 Introduction\fs20\par
\b0\par
This tutorial describes seven sample client programs which have been provided to illustrate how to read spike and digital event data from Plexon OmniPlex (OPX) or MAP systems, continuous data, and tracking data from CinePlex, and to control NIDAQ digital outputs.  \par
\par
\pard{\pntext\f2\'B7\tab}{\*\pn\pnlvlblt\pnf2\pnindent720{\pntxtb\'B7}}\nowidctlpar\fi-720\li720 SimpleRead - Demonstrates the basics of writing and building a client program.\par
{\pntext\f2\'B7\tab}TimeStampRead - Demonstrates how to display individual spike timestamps.\par
{\pntext\f2\'B7\tab}ExternalEventRead \endash  Demonstrates how to read and display external event (digital event) data.\par
{\pntext\f2\'B7\tab}NIDAQRead - Demonstrates how to read and display continuous data.\par
{\pntext\f2\'B7\tab}EventWait - Combines the functionality of TimeStampRead and NIDAQRead and uses Win32 synchronization events to allow minimum-latency operation.\par
{\pntext\f2\'B7\tab}VTRead \endash  Demonstrates how to decode video tracking coordinate data generated by CinePlex.\par
{\pntext\f2\'B7\tab}PlexDO \endash  Demonstrates how to control digital outputs, generate pulses and clock signals from the National Instrument NIDAQ subsystem.\par
\pard\nowidctlpar\par
Each sample client is a Win32 console mode (text only, non-GUI) application.  You should read and try out the samples in order, since they progress from simple to more complex.  The source for each sample is in a .cpp file with the same name as the sample; however, we have tried to stick to "plain vanilla" C and have used a minimum of Windows-specific code.\par
\par
Alternate versions of five of the samples, built using the Microsoft Foundation Classes (MFC), rather than Win32 console mode, are also provided.  These provide the same functionality but support a standard Windows GUI.  See the section on \b MFC clients\b0  for MFC-specific information.\par
\par
Although each sample focuses on one area of functionality, e.g. reading external event data, many real programs will combine the functionality of several of these clients.  You can start with the provided sample code and extend and modify it, or merely use it as a reference for writing your own client from scratch.  \par
\par
Once you understand the operation of the sample client programs, you may wish to read the section \b Additional considerations in client programming\b0 , which covers more advanced client programming topics.\par
\par
The sample clients were originally provided for users of Plexon's MAP (Harvey Box) systems.  However, users of the newer OmniPlex (OPX) system, which is the successor to the MAP, will find that these clients can also be used with OPX systems with little or no change, since the same client API is used.  In the following documentation, "OPX/MAP" will be used to refer to the system from which the client is reading online data.  Similarly, "PlexControl/Sort Client" refers to the main Windows control application for the respective systems.  Please see the section \b OmniPlex clients \b0 for additional OPX-specific considerations.\par
\par
\par
\par
\b Unpacking and building the sample programs\par
\b0\par
The sample clients are provided as one zip file, containing both the C samples and the MFC samples, plus this documentation.  When unzipped, the result should be the following directory structure:\par
\par
SampleClients\par
    bin\par
    C\par
        SimpleRead\par
        TimeStampRead\par
        ExternalEventRead\par
        NIDAQRead\par
        EventWait\par
        VTRead\par
        PlexDO\par
    doc\par
    include\par
    lib\par
    MFC\par
        SimpleRead\par
        TimeStampRead\par
        NIDAQRead\par
        EventWait\par
        VTRead\par
\par
Each bottom-level subdirectory (e.g. \\SampleClients\\C\\TimeStampRead) contains one sample project.  All the examples were built using Microsoft Visual C++ 2005, so each project is represented by a .vcproj project file.  To work with a sample, start up Visual C++.  Use the Open Solution command to open the .vcproj file for the desired sample.  Do a rebuild and the sample will be ready to run.  You can also build all of the samples at once by opening the SampleClients.sln solution file in the \\SampleClients\\C directory and rebuilding the entire solution.  \par
\par
The \i include\i0  directory contains the header files Plexon.h, which contains declarations of the Plexon functions and related constants, and PlexDO.h, which contains declarations for the PlexDO digital output API.  Standard C header files such as stdio.h and stdlib.h are included as needed.  Each sample is linked with the library PlexClient.lib and/or PlexDO.lib, found in the \i lib\i0  directory, in addition to the usual Windows libraries.\par
\par
Make sure you already have the system running (PlexControl and OmniPlex Server for OPX systems, or Sort Client and MAP Server for MAP systems), preferably with some active units sorted, before you run the client.  The client executable should be run from the same directory as the other Plexon executables; if you get an error message complaining that PlexClient.dll could not be found, this is usually caused by trying to run a client in the wrong directory.\par
\par
\par
\b Questions?\par
\b0\par
If you have any questions about building, running, or understanding the clients, or questions in general about writing clients, please feel free to contact Larry Spence at larry@plexon.com.\par
\fs24\par
\par
\b SimpleRead\par
\b0\fs20\par
SimpleRead periodically reads timestamps (but not spike waveforms) from the Server, each time printing a line to the console window showing the total number of spike timestamps read.  It consists of a single main( ) function.  \par
\par
First, it calls PL_InitClientEx3( ), which connects the client to the Server.  This call registers the client with the Server and must be made by a client before any other Server functions can be called.  If you have forgotten to start up the Server and SortClient, you will notice a long pause as the Server is loaded and started before the call returns to the client.\par
\par
Note that any number of independent clients can each register with the Server in any order at any time, and each client can read data from the Server completely independently of the other clients.  As far as a particular client is concerned, the Server is reading data from OPX/MAP and providing it to that client alone.\par
\par
The malloc( ) allocates a buffer in which the Server will return the timestamps.  The buffer is an array of structures of type PL_Event, which is the basic data structure for a single spike timestamp.\par
\par
Finally, we enter an infinite loop, until the user closes the window by clicking on the console window\rquote s close box.  In each pass through the loop, we call PL_GetTimeStampStructures( ), which copies the latest batch of timestamps from the Server into the buffer we allocated, and sets NumTimeStamps to the actual number of timestamps in the buffer.  Note that the value we passed in for NumTimeStamps is the maximum number of timestamps to be passed back to SimpleRead each time.  If, after the call, NumTimeStamps is 0, there was no activity since the last time we called PL_GetTimeStampStructures( ).  On the other hand, if NumTimeStamps is unchanged, this indicates that the buffer was completely filled, and there may be more timestamps in the Server which were not returned to us on this call, but which will be returned in the next call to PL_GetTimeStampStructures( ).  How large a buffer is needed to receive all the timestamps in one call is dependent on the number of channels, peak firing rate, and how frequently you call PL_GetTimeStampStructures (i.e. poll).\par
\par
Next, we step through the array of PL_Event structures returned from PL_GetTimeStampStructures( ).  The loop in SimpleClient adds up the number of sorted spikes on all channels.  This total will depend on the total number of sorted units in SortClient and the firing rate.\par
\par
The printf( ) writes the number of PL_Events and the number of timestamps to the console window.  The app then goes into an idle state for one second, using the Sleep( ) function.  It is important to insert a call to Sleep( ) in a loop such as this, to prevent the client from using excessive CPU time by polling the Server at an unnecessarily high rate (see the EventWait sample for a more efficient way of doing this).  We then return to the top of the loop to fetch another batch of timestamps.  \par
\par
Although it is not important in this client, you should note that within a batch of PL_Events returned by the Server to a client, channels may occur in any order.  It is the responsibility of clients to maintain per-channel buffers or any other suitable internal data structure as needed.\par
\par
For simplicity, this demo assumes that the user will close the app by clicking on the close box in the upper right corner of the console window.  This immediately exits the program without disconnecting from the Server, which is bad form.  However, it will cause no problems, other than the Server displaying an incorrect count of the number of connected clients.  In a real client, you would recognize some condition within the infinite loop (a command, or some condition) as an indication to break out of the loop and clean up.  In this case, cleanup consists of freeing the buffer that we allocated, and calling PL_CloseClient( ) to disconnect from the Server.\par
\fs24\par
\par
\b TimeStampRead\par
\b0\fs20\par
TimeStampRead is similar in overall structure to SimpleRead, but decodes the PL_Event in more detail and dumps information on every timestamp to the console window.  The setup is identical aside from the call to PL_GetTimeStampTick( ), a function which returns the timestamp resolution in microseconds.  For most OPX/MAP systems, this will be 25 microseconds, corresponding to a sampling rate of 40 kHz.\par
\par
The infinite loop is the same, except that for each timestamp, we extract the channel, unit, and actual time and print them to the console window.  Each PL_Event that represents a spike timestamp has fields for Channel, Unit, and TimeStamp.  Channel is a 1-based spike channel number (1 = SPK01, 2 = SPK02...) and Unit indicates the sorted unit on that channel.  For example, if Channel = 29 and Unit = 3, this is channel SPK29c, which is the same as MAP "DSP channel" DSP29c.  TimeStamp is a 32 bit integer representing the time at which the spike crossed the threshold, in units of OPX/MAP clock ticks.  For example, on a 40 kHz OPX/MAP system, a timestamp of 400000 corresponds to 10 seconds after the system clock was started or reset.  The clock is reset on powerup and whenever the Start button is clicked.  For each timestamp we display in the console window, we divide the timestamp by the OPX/MAP sample rate to get the time in seconds.  Note that for even small numbers of channels, quite a bit of output may be generated in the console window.\par
\par
The remainder of the code is identical to SimpleRead.\par
\b\fs24\par
\par
ExternalEventRead\par
\b0\fs20\par
ExternalEventRead is similar in overall structure to TimeStampRead, but only looks for PL_Event data blocks whose Type field is equal to PL_ExtEvent.  These represent external events which are timestamped by OPX/MAP\rquote s digital input (DI) boards, plus certain system events.  Besides the timestamp, there are only two fields of interest, Channel and Unit, whose interpretation can be somewhat complex:\par
\par
\pard\nowidctlpar\fi-360\li720\tx720 1.\tab If the value of Channel is PL_StartExtChannel, PL_StopExtChannel, PL_Pause, or PL_Resume (constants which are #defined in Plexon.h), then there is no additional event data besides the timestamp.  These events are generated by PlexControl/SortClient to indicate when recording of a PLX file has started, ended, paused, or resumed.\par
\pard\nowidctlpar\par
\pard\nowidctlpar\fi-360\li720\tx720 2.\tab If the value of Channel is PL_StrobedExtChannel, the strobed external event channel, then the 16 bit Unit field is decoded as follows.  If the DI board was operated in Mode 3 (see the DI board documentation for details on how to configure a DI board for various modes of operation), the lower 15 bits of the Unit field contain the actual strobed external word value that was read.  In the less common case of Mode 2, only the lowest 8 bits contain the strobed word value.  In either Mode 2 or 3, the high order bit of Unit can be used to distinguish between data from two separate strobed-word DI boards: if the high bit of Unit is 0, the corresponding DI board was installed on DSP section 0 (the top DSP on the leftmost (lowest numbered) DSP board).  If the high bit is 1, the DI board was installed on some DSP section \i other than\i0  section 0.  Thus, one of the two Mode 2/3 DI boards must be installed on DSP section 0 for the high bit to be able to distinguish between them.  Also note that in order for the high bit to be encoded as described, the \ldblquote Set high bit\rdblquote  option in the Server\rquote s Options dialog must be checked; otherwise, the high bit will be 0 regardless of the location of the Mode 2/3 DI board.  For the corresponding options for an OPX system, right-click on the Plexon Digital Input device in the topology diagram shows in Server, and select "Device Options."\par
\pard\nowidctlpar\par
\pard\nowidctlpar\fi-360\li720\tx720 3.\tab If the value of Channel is not one of the above, then it represents the actual event channel number for an unstrobed (single-bit) external event, i.e. DI board Mode 1.  In this case, the Unit field contains the number of the MAP DSP section on which the DI board is installed.  In other words, different Mode 1 DI boards will have the same Channel numbers, but the Unit number can be used to distinguish them.  For OPX systems, currently only a single DI board is supported, and if both 16 bit ports are set to Mode 1, the Unit field indicates the port number.\par
\pard\nowidctlpar\par
If this seems confusing, it may be helpful to read it in conjunction with the sample code that decodes the Channel and Unit fields.\par
\par
Note that keyboard events from PlexControl/Sort Client are encoded as single-bit (unstrobed) event channels starting at channel 101.  For example, pressing Alt-5 in PlexControl/SortClient generates an event on channel 105.\par
\par
The sample code performs the above decoding and dumps out one line per external event, identifying the type of external event, timestamp, and event-specific information such as the strobed word value.\par
\par
The remainder of the code is identical to TimeStampRead.\par
\fs24\par
\par
\b NIDAQRead\par
\b0\fs20\par
NIDAQRead demonstrates how to read continuous digitized data.  The naming originates from the MAP system's use of National Instruments NIDAQ cards to acquire continuous data, but the same client APIs also provide access to continuous wideband, spike-filtered, and field-potential data from an OmniPlex system.  \par
\par
Unlike thresholded spike waveform data, continuous data is a stream of digitized sample values, although it is delivered to clients in successive small blocks of samples, each timestamped with the time of the first sample in the block.  \par
\par
Before running this client, you must have at least one source of continuous data in your OPX topology (this will be the case with any standard topology), or NIDAQ enabled in the MAP Server, and preferably only one or a few continuous channels enabled in PlexControl/Sort Client.  Enabling only one channel is suggested for this client due to the large volume of data generated with multiple channels and the fact that this client dumps \i all\i0  of the samples to the console window.  You may need to hit Control-S to pause the console window updating to observe the output when you run this client.\par
\par
The setup is similar to TimeStampRead, with two changes.  First, instead of using the PL_Event structure,\par
we allocate an array of PL_WaveLong.  This structure contains extra information for the continuous data.  Second, there is a call to the function PL_GetSlowInfo( ), which returns the continuous sampling rate.  The second and third parameters are not used in this client and can be ignored; appropriate dummy parameters are supplied.\par
\par
Within the infinite loop, we call PL_GetLongWaveFormStructuresEx2( ), which fills in the array of  PL_WaveLong which we allocated.  This is essentially a superset of the previous use of  PL_GetTimeStampStructures( ) to return timestamps in an array of PL_Event.  In other words, PL_GetLongWaveFormStructuresEx2( ) will return \i both\i0  spike timestamps and continuously digitized sample data.  As with a PL_Event, the Type field of each PL_WaveLong indicates which type of data it contains.\par
\par
Whereas in the TimeStampRead client we looked for spike timestamps (Type == PL_SingleWFType), here we look for blocks of continuous samples, where Type == PL_ADDataType.  Note that in the case of spike timestamps, each PL_Event structure represents one spike.  However, with continuous data, each PL_WaveLong contains several consecutive samples on a single channel.  Therefore, within the loop that steps through all the PL_WaveLong structures, once we find a block of continuous samples (here we only look for channel 0 to keep things simple), we step through all of the samples in the block.  The PL_WaveLong contains the number of samples in the block and the timestamp (again in OPX/MAP clock ticks) of the first sample in the block.  Each subsequent sample in the block has an implicit timestamp of one sampling tick later than the previous sample. NIDAQRead displays the actual digitized value and the timestamp (converted to seconds) for each sample.  For a typical MAP setup, the NIDAQ card will digitize waveforms into 12 bit signed samples, e.g. a range of -2047 to +2047.  For OPX systems, all continuous data will be represented by 16 bit sample values, e.g. a range of -32767 to +32767.  \par
\par
The remainder of the code is identical to SimpleRead and TimeStampRead.\par
\par
\par
\b\fs24 EventWait\par
\b0\fs20\par
EventWait combines the functionality of TimeStampRead and NIDAQRead and introduces a method for synchronizing operation with the OPX/MAP Server by waiting for a notification that new data is available, rather than polling at a fixed rate.\par
\par
In the previous sample clients, the client and the Server were totally asynchronous.  That is, the Server continually fetches timestamps and continuous data from OPX/MAP, and places them in an internal buffer (the MMF, or memory mapped file).  As long as a given client reads the data from the Server by calling PL_GetTimeStampStructures( ) or PL_GetLongWaveFormStructuresEx2( ) before the data expires in the MMF, all is well.  In particular, the Server never waits on clients to read the data; it simply makes it available for them to read if and when they wish, and for each client maintains a pointer to where that client last read MMF data.  Note that the MMF is typically several megabytes long, and its size can be set in the Server options.  Both OPX Server and MAP Server provide a "wraparound bar graph" which shows the rate at which data is filling up the MMF - you can use this to get an idea of how long the client data is available before it is overwritten by newer data.  Both OPX and the MAP allow the size of the MMF to be specified in the Server options.\par
\par
However, some clients may want to obtain the latest timestamps and digitized data from the Server as soon as they are available and with minimum latency.  In order to do this without inefficient high-speed polling, it is necessary to use a Win32 synchronization object referred to as an "event."  \par
\par
\i NOTE: In the context of Win32 programming, an "event" refers to a type of Win32 synchronization object; this is completely different from the Plexon "PL_Event" data structure type, whose name derives from the common practice of referring to a spike firing as a "spike event," or from external events (TTL digital events).  Any time a Plexon function or data type has "event" as part of its name, it refers to a spike event or external event, not a Win32 synchronization object.\par
\par
\i0 It is beyond the scope of this tutorial to discuss Win32 synchronization in general.  You should consult a book on Windows programming for details.  Suffice it to say that the technique in this sample client could be used as part of a client that handled reading data from the Server in one thread of execution while computation and user interface chores were handled by other threads.  In EventWait, which is not multithreaded, we only use the simplest synchronization to insure that the client is notified by the Server as soon as new timestamps are available.\par
\par
In EventWait, a call to the Win32 function OpenEvent( ) is used to obtain a handle to the standard Plexon Server synchronization event, which is specified as \fs18\ldblquote\f1 PlexonServerEvent\f0\rdblquote .  \fs20 The Server will signal the Server event each time that it completes reading timestamps from the OPX/MAP hardware.  \par
\par
Most of the main loop consists of what amounts to the timestamp decoding from TimeStampRead plus the continuous data decoding from NIDAQRead.  Note that we use PL_GetLongWaveFormStructuresEx2( ) to get both the spike timestamps and the continuous samples, again using the Type field of each PL_WaveLong structure to distinguish the two.  However, instead of a simple Sleep( ) call, we use a call to the Win32 function WaitForSingleObject( ).  When execution reaches this call, the system yields control to other processes, as does the Sleep( ) function; however, rather than this being for a fixed interval such as one second, execution resumes only when the Server signals the server event.  For MAP systems, this interval will be approximately the polling interval set in the Server options.  This will typically be well under 100 ms (typically 10-20 ms), so that the loop will execute at a rate of at least 10 Hz (typically 50-100 Hz, assuming there is new data to be delivered to clients).  So if the Server has a polling interval of 20 ms, this means that roughly every 20 ms the Server will poll the MAP hardware, transferring data to the MMF, then immediately signal the server event, effectively resuming execution in all clients which are waiting on the server event.  Once the flow of execution in a client hits WaitForSingleObject( ) again, it is suspended until the next time the Server reads data from the hardware and signals the event.  For OPX systems, rather than specifying the polling time directly, there is a Device Option for the AD64 device that selects either normal latency, corresponding to approximately 100 ms, or low latency, corresponding to approximately 10 ms.  OPX DigiAmp systems currently implement a fixed latency of approximately 10 ms, but this may be reduced in future versions.\par
\par
Note that due to Windows system activity, it is possible that the actual update interval will sometimes be longer (or on Windows 7 systems, shorter) than the expected interval.  Therefore, even if the data flow from the hardware is perfectly regular, clients cannot be guaranteed that they will receive the exact same amount of data each time the Server signals that data is ready, i.e. the Server event should not be relied upon as a precision timer.\par
\par
The remainder of the code in EventWait is the same as the previous clients, with the addition of a call to CloseHandle( ) to close the server event.\par
\par
\par
\par
\b\fs24 VTRead\par
\b0\fs20\par
VTRead demonstrates how to decode CinePlex position (coordinate) data, which is read by clients as a series of OPX/MAP strobed external events.  For example, the X coordinate is contained in one PL_ExtEvent, the Y coordinate in the next PL_ExtEvent, etc.  The files vt_interpret.h and vt_interpret.cpp contain helper functions that clients can use to decode tracking position data from this series of strobed events, which are not guaranteed to be adjacent in the data stream from the hardware, e.g. there may be intervening spikes between an X coordinate and its associated Y coordinate.  As soon as a complete \ldblquote package\rdblquote  of coordinate data has been received, it is printed.\par
\par
\par
\b\fs24 PlexDO\par
\b0\fs20\par
PlexDO demonstrates how to control digital outputs, generate pulses and clock signals on National Instruments NIDAQ cards.  This can be used to control hardware devices, communicate and synchronize with behavioral control or other data acquisition systems, etc.  The PlexDO sample client is somewhat different in that it does not interact with the OPX/MAP Server, although the PL_DO* functions can be called from a normal OPX/MAP client program if desired.  In short, even if OPX/MAP is using the NIDAQ card for continuous data acquisition, the digital output subsystem can be used completely independently by a client program.  See the separate document PlexDOReadme.rtf for details on using PlexDO and the PlexDO sample code.\par
\par
\b\fs24\par
MFC clients\par
\b0\fs20\par
The MFC versions of the sample clients follow the functionality of the Win32 versions for the most part, with the following notable differences.\par
\par
\b\par
MFCSimpleRead\par
\b0\par
Rather than sitting in an infinite loop with a Sleep statement providing a delay as in the Win32 SimpleRead, a timer is created using SetTimer, and an OnTimer handler is used.\par
\par
\par
\b MFCTimeStampRead\par
\b0\par
MFCTimeStampRead is similar in overall structure to MFCSimpleRead, but decodes the PL_Event in more detail.  For each of the first eight unit channels, SPK01a through SPK02d, we keep a count of the number of timestamps (spikes).  After we have looped through all the OPX/MAP events, the count of spikes on each channel is displayed in the dialog box.  For each timestamp on the first eight unit channels, we also dump the spike channel number, unit, and time in seconds to the Visual C++ debug window, using the standard TRACE macro.\par
\par
\par
\b MFCNIDAQRead\par
\b0\par
The continuous-data-specific code is similar to the console-mode NIDAQ sample, except for the display of the continuous data.  Each time we get a new batch of events from the Server, we loop through the events, looking only for continuous sample blocks on the first channel.  For this channel, we display the first eight samples in the block in the dialog box, showing the timestamp and the digitized value for each sample.  \par
\par
\par
\b MFCEventWait\par
\b0\par
MFCEventWait is similar to the console-mode EventWait sample, but also shows basic multithreading techniques.  It starts a second "reading" thread which is dedicated to waiting on data from the Server.\par
\par
When the user clicks the Connect button, after the usual initialization the function StartReadThread( ) is called.  StartReadThread( ) begins by resetting KillDataThreadEvent, a Win32 event which is used on shutdown to signal to the reading thread to kill itself.  Next, the Server poll event is opened, as in the console-mode EventWait.  Finally, the MFC function AfxBeginThread( ) is used to actually begin execution of the reading thread, whose thread function is ReadThreadFunc( ).  A pointer to KillDataThread is passed so that the reading thread can use it to determine when to kill itself.\par
\par
ReadThreadFunc( ) does three main things inside of an infinite loop.  First, it waits on the kill event, but with a timeout of 0, so that execution continues immediately unless the kill event has been signaled.  This happens on shutdown from OnDestroy( ), where the call to KillDataThreadEvent.SetEvent( ) is made.  When this event is signaled, the reading thread calls the MFC function AfxEndThread( ) and terminates.\par
\par
Second, assuming that the kill event has not been signaled yet, the reading thread sends a WM_USER+1 message to the main thread, indicating that it should read a batch of events from the Server.  Since this is a SendMessage( ), as opposed to a PostMessage, the reading thread will wait until the main thread has processed the WM_USER+1 message before continuing.  \par
\par
Last, after the main thread finishes processing the message, the reading thread waits on the Server polling event.  The reading thread is suspended until the Server signals the polling event again.\par
\par
The WM_USER message is handled in OnServerReady( ).  The MFC technique for associating this function with the WM_USER+1 message is to manually add an ON_MESSAGE entry in CMFCEventWaitDlg's message map.  OnServerReady( ) reads a batch of timestamps from the Server and displays the number of events in the dialog box.  The more detailed decoding of spike timestamps and/or NIDAQ samples found in the other clients is omitted for simplicity.\par
\par
As already mentioned, when the dialog closes, OnDestroy( ) in the main thread signals the reading thread to kill itself.  It also frees  the timestamp buffer and closes the handle to the Server poll event.\par
\par
This sample client present only one of many possible ways to organize a multithreaded client.  A more advanced client might have several threads, e.g. one for reading data from the Server, one for updating displays, one for handling user interaction, etc, and might share data between threads using one or more ring buffers with the appropriate synchronization of access.  Such techniques are beyond the scope of this tutorial; please contact Plexon for more information.\par
\par
\par
\par
\b\fs24 Additional considerations in client programming\par
\b0\fs20\par
\par
\b Long timestamps\par
\b0\par
Note that each PL_Event also contains a single-byte field UpperTS, which is an extension to the 32 bit TimeStamp field.  UpperTS is nonzero unless the OPX/MAP has been running for more than 29.8 hours (at 40 kHz per channel) without a restart, which is the time at which the 32 bit TimeStamp field rolls over:\par
\par
             (2^32 / 40000 Hz) / (3600 sec/hr) = 29.8 hours\par
\par
In many cases, clients can safely assume the UpperTS field will be zero and use only the TimeStamp field.  If in doubt, simply check the UpperTS field to verify that it is zero.  \par
\par
If all 40 bits of the OPX/MAP timestamp are to be used, either a double (64 bit floating point) or a 64 bit integer can be used to store the timestamp without loss of precision.  For example, the following macro can be used to construct a 64 bit integer or double precision float timestamp from TimeStamp and UpperTS:\par
\f1\fs16\par
        #define MakeLongTimeStamp(upper8, lower32) \\\par
            ( ((LONGLONG)(upper8)<<32) + (LONGLONG)(lower32) )\par
\par
        LONGLONG TimeStamp64 = MakeLongTimeStamp(MAPEvent.UpperTS, MAPEvent.TimeStamp);\par
        double dTimeStampInSeconds = (double)TimeStamp64/40000.0;\par
\b\f0\fs20\par
\par
Broadcast messages\par
\b0\par
The MAP Server sends WM_COPYDATA messages to all active clients to inform them of certain state changes in PlexControl/SortClient, such as gain changes, start of recording, etc.  A pointer to a COPYDATASTRUCT is passed in the lParam message parameter.  This code fragment shows how to interpret the contents of the COPYDATASTRUCT:\par
\f1\fs16\par
        COPYDATASTRUCT *pCopyDataStruct = (COPYDATASTRUCT*)lParam;\par
        DWORD cmd = pCopyDataStruct->dwData;\tab\par
        DWORD count = pCopyDataStruct->cbData;\par
        int params[8];\par
        memcpy(params, pCopyDataStruct->lpData, 32);\par
\par
        switch(cmd)\par
        \{\par
          case 1:  // set number of units \par
            DSPChan = params[0];\par
            NumUnits = params[1];\par
            break;\par
          case 2:  // start recording\par
            break;\par
          case 3:  // stop recording\par
            break;\par
          case 4:  // set active channel\par
            DSPChan = params[0];\par
            break;\par
          case 5:  // SWH crosspoint on\par
            ChanIn = params[0];\par
            ChanOut = params[1];\par
            break;\par
          case 6:  // SWH crosspoint off\par
            ChanOut = params[0];\par
            break;\par
          case 7:  // set gain\par
            SIGChan = params[0];\par
            SIGGain[SIGChan] = params[1]*PreampGainMult;\par
            break;\par
          case 8:  // set global gain\par
            GlobalGain = params[0]*PreampGainMult;\par
            break;\par
          case 9:  // set filter enable\par
            SIGChan = params[0];\par
            bSIGChanFilterEnabled[SIGChan] = (params[1] != 0);\par
            break;\par
          case 10: // set global filter enable\par
            bFilterEnabledGlobal = (params[0] != 0);\par
            break;\par
          case 11: // restarting data acquisition\par
            break;\par
          case 12: // start data pump\par
            break;\par
          default:\par
            break;\par
        \}\par
\par
\f0\fs20\par
Clients are not required to include a handler for WM_COPYDATA messages.\par
\par
OmniPlex systems do not currently support broadcast messages.\par
\par
\b\par
Buffering and latency \par
\b0\par
Some clients immediately process the timestamps from OPX/MAP and have no need to save them.  However, in many cases a client will maintain its own buffer of OPX/MAP data, for example, a circular buffer (ring buffer) of the most recent data; data is appended to one end of the buffer and consumed from the other end.  Since the PL_Get* functions return the data from all channels in a single array, often clients will find it more convenient to store this data in their own per-channel buffers; as timestamps are received, each is appended to the buffer for the corresponding channel.  It is guaranteed that the timestamps for any given channel will be received in time-increasing order.\par
\par
Some clients, for example a real-time client which is decoding motor activity in order to control a prosthetic device, need to operate with minimum latency.  To minimize latency, follow these recommendations:\par
\par
\pard\nowidctlpar\fi-360\li720\tx720 1.\tab Set the polling interval in the MAP Server Options to the minimum value of 10 milliseconds.  For OPX AD64 systems, set low latency mode in the AD64 Device Options.  For OPX DigiAmp systems, the default latency is approximately 10 ms, but can be reduced to approximately 1 ms by enabling "lowest latency" in the DigiAmp Device Options.  Note that on a multiprocessor, multi-core, or hyperthreaded PC running Windows XP, the minimum polling interval is 15.625 ms, even if you specify 10 ms; this is determined by the Windows scheduler clock.  On Windows 7 systems, you may get a longer or shorter interval than you specified.  However, DigiAmp systems with "lowest latency" enabled typically have a fairly tight distribution of latency values, centered on 1 ms.\par
\pard\nowidctlpar\fi-360\li720 2.\tab Use the synchronization method shown in the EventWait sample client; do not use polling.\par
3.\tab Be very careful about elevating the process or thread priority of your client, or other applications, above normal; this can actually increase latency in some cases.\par
4.\tab Do not run CPU-intensive applications on the same machine as the OPX/MAP Server; if this is necessary, a fast machine with at least four cores is recommended; for high channel count OPX systems, or systems which are concurrently running CinePlex, six cores or more may be necessary.  The Windows Task Manager (or Resource Monitor on Windows 7) shows the percentage of CPU being used by each processor, core, or hyperthreaded execution unit.\par
5.\tab Watch out for system processes such as virus scanners, disk defragmenters, network administration tasks, Windows Update, etc., media players, etc., which can sometimes cause prolonged interruption of user applications.\par
\pard\nowidctlpar\par
OmniPlex users should also refer to the appendix on lowest latency operation in the User Guide.\par
\par
An issue which can be ignored by most clients involves buffering in the MAP itself (this section does not apply to OPX systems).  The internal hardware buffers in the MAP are written (by the MAP DSP software) and read (by the MXI or HLK2 host link in the PC) asynchronously.  It is guaranteed that the host will not miss data (unless there is a \ldblquote drop\rdblquote  caused by not reading the data fast enough) or read the same data twice, and the timestamps will always be correct.  However, the asynchronous operation means that occasionally a spike that should have been delivered to clients in one MAP polling cycle (typically 10 ms) will not be read until the next polling cycle.  The timestamp itself will be correct, but the spike will be \ldblquote delivered late\rdblquote  to the Server.  This happens rarely; unless firing rates are very high, less than 1% of spikes will be affected.  Also, note that for any one channel, all the timestamps will always be delivered in strictly time-monotonic order, and even in the worst case, a spike will never arrive in the host more than one polling cycle late.  If this is an issue, a client should buffer timestamps so that the timestamps for one polling cycle are not processed until the \i next\i0  batch of timestamps is received; this introduces one additional polling cycle of latency.\par
\par
Note: under some conditions, MAP Server can operate with a poll interval as low as 1 ms; contact Plexon for more information.\par
\b\par
\par
Other PL_* functions\par
\b0\par
A number of PL_Get* functions are provided which return various global and per-channel parameters.  Many of them follow a standard pattern which is illustrated by the \f1\fs16 PL_GetGain\f0\fs20  function:\par
\f1\par
\fs16         extern "C" void WINAPI PL_GetGain(int* gain);\par
\f0\fs20\par
This returns the current SIG board gain setting (gain multiplier) for all 128 /OPXMAP channels in a single call.  It expects to be passed an array of 128 ints, and returns the gain for channel 1 in the [0] element, for channel 2 in the [1] element, etc.  In general, PL_Get* functions which do not take a \f1\fs16 ch\f0\fs20  (channel) parameter and which apply to multiple channels (gain, filter, threshold, etc.) expect to return values in one or more arrays of 128 ints, i.e. all pointer parameters are used for returning values.  \par
\par
Note that these functions are not fully compatible with OPX systems, and should be used with caution.  Some functions, such as PL_GetOUTInfo and PL_GetFilter, refer to MAP hardware functions which do not have direct equivalents in OPX.  Other functions, such as PL_GetGain, only support up to 128 channels, corresponding to the largest MAP configuration, and therefore are of limited use with OPX DigiAmp systems of greater than 128 channels.  A future API update will address these limitations and provide access to OPX-specific information which is not available via the "classic" client API.\par
\par
A list of available functions for querying per-channel and global system parameters follows.\par
\par
\par
\f1\fs16 ///////////////////////////////////////////////////////////////////////////////////\par
// functions related to MAP configuration\par
//\par
\par
// note that for historical reasons, there is some overlap of functionality \par
// between these functions\par
\par
void WINAPI PL_GetGlobalPars(int* numch, int* npw, int* npre, int* gainmult);\par
// numch    = number of DSP channels\par
// npw      = number of points per spike waveform\par
// npre     = number of prethreshold points per spike waveform\par
// gainmult = preamp gain multiplier, e.g. 500 or 1000\par
\par
void WINAPI PL_GetGlobalParsEx(int* numch, int* npw, int* npre, int* gainmult, \par
                               int* maxwflength);\par
// as for PL_GetGlobalPars, plus:\par
// maxwflength = maximum length of a spike waveform (usually 56; 120 in some systems)\par
\par
void WINAPI PL_GetChannelInfo(int* nsig, int* ndsp, int* nout);\par
// nsig = number of SIG channels (16-128, total for all boards)\par
// ndsp = number of DSP channels (16-128, total for all boards)\par
// nout = number of OUT channels (0-40, total for all boards)\par
\par
\par
\par
\par
void WINAPI PL_GetOUTInfo(int* out1, int* out2);\par
// out1 = return code for first OUT board;\par
// out2 = return code for second OUT board\par
// encoding of return value for each board:\par
//     0 = no OUT board\par
//     4 = four BNC outputs are present\par
//    16 = 16 channel connector is present\par
//    20 = both BNCs and 16 channel connector are present\par
\par
int  WINAPI PL_SWHStatus();      \par
// returns nonzero if the SWH (crosspoint analog switch) board is present\par
\par
int  WINAPI PL_GetTimeStampTick();\par
// return the MAP timestamp increment (tick), in microseconds\par
// (1000000 / tick) = the MAP digitizing frequency in Hz\par
\par
int  WINAPI PL_GetTIMClockFreq(void);\par
// returns either 40 kHz or 80 kHz\par
\par
int  WINAPI PL_GetPollingInterval();\par
// returns the approximate MAP polling interval in milliseconds\par
\par
\par
///////////////////////////////////////////////////////////////////////////////////\par
// functions related to NIDAQ (continuous acquisition) configuration\par
\par
int  WINAPI PL_IsNIDAQEnabled();\par
// returns nonzero if the NIDAQ subsystem is enabled\par
\par
void WINAPI PL_GetNumNIDAQCards(int* numcards);\par
// returns number of NIDAQ cards present (0-4)\par
\par
int  WINAPI PL_GetNIDAQNumChannels();\par
// returns the number of channels per NIDAQ card (all cards must be the same model and\par
// therefore will have the same number of channels per card); typically 16 or 64\par
\b\par
\b0 void WINAPI PL_GetNIDAQCardSlow4(int* IsSlow);\par
// expects to be passed an array of 4 ints; for each entry,\par
// 0 means that card is operating at the \ldblquote fast\rdblquote  (MAP) digitizing rate\par
// 1 means that card is operating at the \ldblquote slow\rdblquote  (LFP) digitizing rate\par
\par
// Note: the PL_GetSlowInfo* functions are for systems with 16, 64, and up to 256\par
// total NIDAQ channels respectively; the older 16 and 64 channels versions are \par
// supported for backwards compatibility only\par
void WINAPI PL_GetSlowInfo(int* freq, int* channels, int* gains);\par
// this function is for systems with only a single 16 channel NIDAQ card\par
//   freq     = \ldblquote slow\rdblquote  (non-MAP) digitizing rate \par
// expects to be passed arrays of 16 ints each for channels and gains:\par
//   channels = each element is 1 if that channel is enabled, 0 if disabled\par
//   gains    = each element contains the NIDAQ gain (1,2,5,10,...) for that channel\par
\par
void WINAPI PL_GetSlowInfo64(int* freq, int* channels, int* gains);\par
// this function is for systems with only a single 64 channel NIDAQ card\par
//   freq     = \ldblquote slow\rdblquote  (non-MAP) digitizing rate \par
// expects to be passed arrays of 64 ints each for channels and gains:\par
//   channels = each element is 1 if that channel is enabled, 0 if disabled\par
//   gains    = each element contains the NIDAQ gain (1,2,5,10,...) for that channel\par
\par
void WINAPI PL_GetSlowInfo256(int* freqs, int* channels, int* gains);\par
// this function supports any NIDAQ configuration, up to the maximum of four\par
// NIDAQ cards of 64 channels each\par
//   freq     = \ldblquote slow\rdblquote  (non-MAP) digitizing rate \par
// expects to be passed arrays of 256 ints each for channels and gains:\par
//   channels = each element is 1 if that channel is enabled, 0 if disabled\par
//   gains    = each element contains the NIDAQ gain (1,2,5,10,...) for that channel\par
\par
int  WINAPI PL_GetNIDAQBandwidth(void);\par
// returns the aggregate digitizing bandwidth of each NIDAQ card, in samples/sec\par
\par
\par
///////////////////////////////////////////////////////////////////////////////////\par
// general system status functions\par
\par
int  WINAPI PL_IsDSPProgramLoaded();\par
// returns nonzero if the MAP DSP software has been loaded\par
\par
int  WINAPI PL_IsSortClientRunning();\par
// returns nonzero is SortClient is running\par
\par
int  WINAPI PL_GetActiveChannel();\par
// returns the current active channel number in SortClient\par
\par
\par
///////////////////////////////////////////////////////////////////////////////////\par
// functions returning per-channel state information for all MAP channels\par
\par
// The following six functions all expect to be passed a pointer to an array of 128 ints\par
// which are filled with per-channel values by the function\par
\par
void WINAPI PL_GetSIG(int* sig);\par
// for each channel, returns the SIG channel connected to that DSP channel\par
// (only applies if SWH board used)\par
\par
void WINAPI PL_GetFilter(int* filter);\par
// returns 0 or 1 for each channel to indicate whether the low-cut filter is enabled\par
\par
void WINAPI PL_GetGain(int* gain);\par
// returns the gain multiplier for each channel; multiply by the global gain multiplier \par
// (preamp gain - see PL_GetGlobalPars) to get the total per-channel gain\par
\par
void WINAPI PL_GetMethod(int* method);\par
// returns the sorting method for each channel; 1 = boxes, 2 = templates\par
\par
void WINAPI PL_GetThreshold(int* thr);\par
// returns the threshold for each channel, in MAP A/D converter units (-2048..+2047)\par
\par
void WINAPI PL_GetNumUnits(int* numunits);\par
// returns the number of sorted units (0..4) for each channel \par
\par
\par
///////////////////////////////////////////////////////////////////////////////////\par
// functions related to template sorting\par
\par
void WINAPI PL_GetTemplate(int ch, int unit, int* t);\par
// for the given channel and unit, returns the template points in the array t;\par
// the length of t must be at least the number of points per spike waveform \par
// (see PL_GetGlobalPars); template points are in MAP A/D units (-2047..+2048)\par
\par
void WINAPI PL_GetNPointsSort(int* npts);\par
// returns the sort width (number of waveform points used in template sorting)\par
///////////////////////////////////////////////////////////////////////////////////\par
// channel name functions\par
\par
void WINAPI PL_GetName(int ch1x, char* name);\par
// returns the name string for the given spike channel (1-based)\par
\par
void WINAPI PL_GetEventName(int ch1x, char* name);\par
// returns the name string for the given event channel (1-based)\par
\par
void WINAPI PL_GetSlowChanName(int ch0x, char* name);\par
// returns the name string for the given \ldblquote slow\rdblquote  (continuous) channel (0-based)\par
\f0\par
\par
\pard\fs20 As with other client development issues, please feel free to contact Larry Spence at {\field{\*\fldinst{HYPERLINK "mailto:larry@plexoninc.com" }}{\fldrslt{\ul larry@plexon.com}}}\ulnone\f0\fs20  for additional information on any of the functions whose use is not obvious.\par
\par
\par
\b OPX/MAP time versus Windows time\par
\b0\par
A common question is, \ldblquote how can my client read the clock?\rdblquote  i.e. how does a client access the timestamp clock in the OPX/MAP hardware?  For MAP systems, there is no function call provided to asynchronously \ldblquote get the hardware time,\rdblquote  and such a timestamp would not be very accurate anyway due to Windows scheduling delays, e.g. 10 ms or more could elapse between when a client asked for the MAP time and when the MAP clock was read.  If a periodic clock timestamp is needed, one way of doing it is to simply feed a TTL pulse from an external function generator into one of the MAP\rquote s external event inputs, e.g. XS2.  This pulse will appear in the data stream, accurately timestamped, along with all the other data, and can be used as a \ldblquote frame marker\rdblquote  to be read by clients.  However, make sure that a high-accuracy function generator is used, or it may drift relative to the MAP's internal clock over time.\par
\par
For OPX systems, a software interface to the OPX hardware timestamp clock does exist, and an API for reading the current hardware time will be provided in a future update to the client API.  For the time being, either the timestamps on any channel of continuous data (which unlike MAP/NIDAQ systems, is guaranteed to be present in every OPX system), or the function generator / DI channel method described for the MAP can be used as a workaround. \par
\par
Of course, Windows client programs can read the local \ldblquote Windows time\rdblquote  using functions like GetTickCount( ) or the high-frequency performance counter; consult the Windows API documentation for details.  This is what the Server does to timestamp events which occur on the PC, such as keyboard events.  The Server periodically recalculates a correction factor between the Windows clock and the MAP clock to minimize the discrepancy; the details are beyond the scope of this tutorial.\par
\par
\par
\b Control clients\par
\b0\par
The Plexon client APIs are designed for clients which read data from the OPX/MAP hardware, after the gains, thresholds, etc. have been set via PlexControl/Sort Client.  These are generally referred to as \ldblquote analysis clients,\rdblquote  although of course such a client can record its own files and perform whatever other functions are needed in addition to analysis.  However, it is not currently possible for a user client program to control an OPX/MAP system, since these functions are reserved exclusively to PlexControl/Sort Client.  In the case of OPX systems, these limitations may be addressed in a future API update.\par
\par
\par
\b Clients and PlexNet\par
\b0\par
Client can run on the remote end of a PlexNet connection without change; it is transparent to the client whether it is running locally or remotely.  There may be additional latency and latency variability (i.e. jitter) caused by the network, although in practice this is often minimal.  See the PlexNet documentation for more information.\par
\par
\par
\b OmniPlex clients\par
\b0\par
Although the same API functions are used to read data from either MAP or OPX systems, the MAP system is somewhat more limited and so some clients that were written for the MAP may require modification to be compatible with an OPX system.  Here are some of the differences between the two systems which are relevant to clients:\par
\par
MAP systems have a maximum of 128 spike channels.  OPX DigiAmp systems can currently have up to 256 channels, with higher channel counts in future versions.  Clients which assume a limit of 128 channels may break when run with a larger system.  Note that although as noted previously, some of the APIs do not currently support more than 128 channels, the core data access APIs, e.g. PL_GetLongWaveFormStructures, do support high channel count OPX systems.\par
\par
MAP systems can only sort up to four units (a,b,c,d) per spike channel.  OPX currently supports up to 16 units per channel; although very few users will approach this limit, clients which assume the old four-unit limit may require modification.\par
\par
MAP systems digitize spike waveforms and NIDAQ continuous data as 12 bit sample values stored in 16 bit words (a few MAP systems use 16 bit NIDAQ cards, but this is not officially supported).  OPX systems currently digitize all spike and continuous data as 16 bit values stored in 16 bit words. In both cases, values are passed through the client APIs as 16 bit words, but the range of values is only -2047 to +2047 for MAP data.  Internally, OPX represents all spike and continuous sample data in 32 bit floating point format, but since the A/D resolution is currently 16 bit, the 16 bit client API results in no loss of resolution.  A future version of the API may provide full 32 bit access, in order to support higher-resolution A/D inputs, etc.\par
\par
MAP systems provide continuously digitized data as an option, using one to four NIDAQ cards, each of which is typically operated at either "fast rate" (either 20 kHz or 40 kHz, depending on the hardware) or "slow rate" a.k.a. "FP rate" (typically 1 kHz).  OPX systems inherently provide wideband continuous data at a 40 kHz sample rate on all channels, and derive filtered and/or downsampled versions of that data as additional channels.  For example, a 64 channel OPX system by default provides 192 (i.e. 3 * 64) channels of continuous data: 64 wideband channels at a 40 kHz per-channel rate, 64 channels of highpass-filtered "spike-continuous" data (also at a 40 kHz rate), and 64 channels of downsampled "FP" data, at a default rate of 1 kHz/channel.  A client will by default receive all 192 channels of continuous data, and must use the channel number ranges to identify the type of data.  In OPX Server, click on RASPUTIN Server Emulation Options in the Configure menu to bring up a dialog box which shows the mapping of OPX source channels to Rasputin channel numbers (the same mappings are used when OPX records a plx file).  The Server Emulation page of the same dialog box allows you to set the size of the MMF, as well as a continuous data bandwidth limit for clients.  A larger MMF can allow your clients to read data less frequently, but be aware that an excessively large MMF can degrade system performance.  The client bandwidth limit is very useful for preventing clients from being overwhelmed by unwanted 40 kHz continuous data; for example if your client is only interested in field potential data (the FP sources, in OPX terminology), set the bandwidth limit value to the per-channel rate for those channels, which by default is 1 kHz in OPX systems.   Also, if your client is running on a separate PC via PlexNet, you can use PlexNet to select which channels are sent over the network connection, as an alternate way of reducing the amount of data that a client has to deal with.  Unless one or more of these "throttling" strategies are used, all but the smallest OPX systems will require their clients to read and process data from the Server much more frequently than was the case for the corresponding MAP system, or they will not be able to keep up with the amount of incoming 40 kHz continuous data.\par
\par
}
 